import subprocess, shlex, time
import cv2
import numpy as np

def _open_in(url, timeout_ms=8000):
    cap = cv2.VideoCapture(url, cv2.CAP_FFMPEG)
    cap.set(cv2.CAP_PROP_OPEN_TIMEOUT_MSEC, timeout_ms)
    cap.set(cv2.CAP_PROP_READ_TIMEOUT_MSEC, timeout_ms)
    return cap

def _open_out_ffmpeg(out_url, w, h, fps):
    cmd = (
        f"ffmpeg -loglevel warning -re "
        f"-f rawvideo -pix_fmt bgr24 -s {w}x{h} -r {fps:.2f} -i - "
        f"-c:v libx264 -preset veryfast -tune zerolatency -g {int(max(1,fps))} "
        f"-f rtsp -rtsp_transport tcp {shlex.quote(out_url)}"
    )
    return subprocess.Popen(shlex.split(cmd), stdin=subprocess.PIPE)

def run_highlight_loop(url_in, url_out, log="INFO", fps_target=0.0, open_timeout_ms=8000):
    mog2  = cv2.cuda.createBackgroundSubtractorMOG2(history=500, varThreshold=16, detectShadows=False)
    gauss = cv2.cuda.createGaussianFilter(cv2.CV_8UC1, cv2.CV_8UC1, (5,5), 0)
    morph = cv2.cuda.createMorphologyFilter(cv2.MORPH_OPEN, cv2.CV_8UC1,
                                            cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(3,3)))

    cap = _open_in(url_in, timeout_ms=open_timeout_ms)
    if not cap.isOpened():
        raise RuntimeError("Unable to open input stream")

    ok, frame0 = cap.read()
    if not ok:
        raise RuntimeError("No frames from input")
    h, w = frame0.shape[:2]
    fps = cap.get(cv2.CAP_PROP_FPS) or 30.0
    if fps_target and fps_target > 0:
        fps = fps_target

    pipe = _open_out_ffmpeg(url_out, w, h, fps)

    gpu_bgr  = cv2.cuda_GpuMat()
    gpu_gray = cv2.cuda_GpuMat()
    incr     = cv2.cuda_GpuMat(h, w, cv2.CV_8UC3)
    incr.upload(np.full((h,w,3), 40, dtype=np.uint8))  # Helligkeits-Zugabe

    t_prev = time.time()
    ema = None

    try:
        while True:
            ok, frame = cap.read()
            if not ok:
                time.sleep(0.1)
                continue

            gpu_bgr.upload(frame)
            # gray → blur → bg subtract → clean
            gpu_gray = cv2.cuda.cvtColor(gpu_bgr, cv2.COLOR_BGR2GRAY)
            gpu_gray = gauss.apply(gpu_gray)
            gpu_mask = mog2.apply(gpu_gray, -1.0)
            gpu_mask = morph.apply(gpu_mask)

            # binär
            _, gpu_bin = cv2.cuda.threshold(gpu_mask, 80, 255, cv2.THRESH_BINARY)
            gpu_bin3 = cv2.cuda.cvtColor(gpu_bin, cv2.COLOR_GRAY2BGR)

            # brighten nur auf Bewegung
            gpu_bright = cv2.cuda.add(gpu_bgr, incr)
            motion = cv2.cuda.bitwise_and(gpu_bright, gpu_bin3)
            inv    = cv2.cuda.bitwise_not(gpu_bin3)
            bg     = cv2.cuda.bitwise_and(gpu_bgr, inv)
            out    = cv2.cuda.add(motion, bg)

            pipe.stdin.write(out.download().tobytes())

            if log in ("DEBUG","INFO"):
                t_now = time.time()
                inst  = 1.0 / max(1e-6, (t_now - t_prev))
                ema   = (0.9*ema + 0.1*inst) if ema else inst
                if int(t_now) % 2 == 0:
                    print(f"[motion] fps~{inst:.2f} (ema={ema:.2f})")
                t_prev = t_now

    except KeyboardInterrupt:
        pass
    finally:
        try: pipe.stdin.close()
        except: pass
        pipe.terminate()
        cap.release()
