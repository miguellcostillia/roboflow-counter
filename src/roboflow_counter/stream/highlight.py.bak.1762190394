import time, subprocess, cv2, numpy as np

def _open_capture(url: str, timeout_ms: int = 8000) -> cv2.VideoCapture:
    cap = cv2.VideoCapture()
    cap.open(url, cv2.CAP_FFMPEG)
    t0 = time.time()
    while not cap.isOpened():
        if (time.time() - t0) * 1000 > timeout_ms:
            raise RuntimeError(f"RTSP open timeout after {timeout_ms} ms")
        time.sleep(0.05)
    return cap

def _ffmpeg_writer(out_url: str, w: int, h: int, fps: float) -> subprocess.Popen:
    cmd = [
        "ffmpeg","-loglevel","warning","-re",
        "-f","rawvideo","-pix_fmt","bgr24",
        "-s",f"{w}x{h}","-r",f"{max(1.0,fps):.2f}",
        "-i","pipe:0","-an",
        "-c:v","libx264","-preset","veryfast","-tune","zerolatency",
        "-pix_fmt","yuv420p","-f","rtsp", out_url,
    ]
    return subprocess.Popen(cmd, stdin=subprocess.PIPE)

def _cuda_bgsub_pipeline():
    mog2  = cv2.cuda.createBackgroundSubtractorMOG2(history=500, varThreshold=16, detectShadows=False)
    gauss = cv2.cuda.createGaussianFilter(cv2.CV_8UC1, cv2.CV_8UC1, (5,5), 1.2)
    k     = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))
    morph = cv2.cuda.createMorphologyFilter(cv2.MORPH_CLOSE, cv2.CV_8UC1, k)
    stream= cv2.cuda.Stream()
    return mog2, gauss, morph, stream

def _apply_mog2(mog2, gpu_gray, stream):
    dst = cv2.cuda.GpuMat()
    try:
        mog2.apply(gpu_gray, dst, -1.0, stream); return dst
    except Exception: pass
    try:
        return mog2.apply(gpu_gray, -1.0, stream)
    except Exception: pass
    return mog2.apply(gpu_gray)

def _cvt_gray_gpu(gpu_bgr, stream, frame_cpu):
    dst = cv2.cuda.GpuMat()
    try:
        cv2.cuda.cvtColor(gpu_bgr, cv2.COLOR_BGR2GRAY, dst, stream); return dst
    except Exception: pass
    try:
        return cv2.cuda.cvtColor(gpu_bgr, cv2.COLOR_BGR2GRAY)
    except Exception: pass
    # CPU-Fallback
    gray = cv2.cvtColor(frame_cpu, cv2.COLOR_BGR2GRAY)
    dst.upload(gray, stream)
    return dst

def _gauss_apply_gpu(gauss, gpu_gray, stream):
    try:    return gauss.apply(gpu_gray, stream)
    except: return gauss.apply(gpu_gray)

def _morph_apply_gpu(morph, gpu_mask, stream):
    dst = cv2.cuda.GpuMat()
    try:
        morph.apply(gpu_mask, dst, stream); return dst
    except Exception: pass
    try:    return morph.apply(gpu_mask)
    except: return gpu_mask

def _to3_gpu(gpu_mask, stream, w: int, h: int):
    # Sicher 1ch→3ch auf der GPU via merge (robuster als cvtColor in manchen Builds)
    dst = cv2.cuda.GpuMat()
    try:
        cv2.cuda.merge([gpu_mask, gpu_mask, gpu_mask], dst, stream); return dst
    except Exception: pass
    try:
        cv2.cuda.merge([gpu_mask, gpu_mask, gpu_mask], dst); return dst
    except Exception: pass
    try:
        return cv2.cuda.merge([gpu_mask, gpu_mask, gpu_mask])
    except Exception: pass
    # letzter Ausweg: CPU stack + Upload
    m = gpu_mask.download()
if m is None or not hasattr(m, "shape") or m.size == 0:
    m = np.zeros((h, w), dtype=np.uint8)
elif m.dtype != np.uint8:
    m = m.astype(np.uint8, copy=False)
m3 = np.dstack([m, m, m])
dst.upload(m3)
    return dst

def run_highlight_loop(url_in: str, url_out: str, log: str="INFO",
                       fps_target: float|None=None, open_timeout_ms: int=8000):
    cap = _open_capture(url_in, open_timeout_ms)
    ok, frame0 = cap.read()
    if not ok or frame0 is None:
        raise RuntimeError("Kein Frame vom Eingang")

    h, w = frame0.shape[:2]
    fps = cap.get(cv2.CAP_PROP_FPS) or 8.0
    if not np.isfinite(fps) or fps <= 0: fps = 8.0

    pipe = _ffmpeg_writer(url_out, w, h, fps)
    if not pipe or not pipe.stdin:
        raise RuntimeError("FFmpeg-Pipe nicht verfügbar – ist ffmpeg installiert?")

    mog2, gauss, morph, stream = _cuda_bgsub_pipeline()
    gpu_bgr = cv2.cuda.GpuMat()
    gpu_out = cv2.cuda.GpuMat()

    t_prev = time.time(); ema=None

    while True:
        ok, frame = cap.read()
        if not ok or frame is None:
            time.sleep(0.02); continue

        gpu_bgr.upload(frame, stream)

        # gray → blur
        gpu_gray = _cvt_gray_gpu(gpu_bgr, stream, frame)
        gpu_gray = _gauss_apply_gpu(gauss, gpu_gray, stream)

        # bg subtract + clean
        gpu_mask = _apply_mog2(mog2, gpu_gray, stream)
        gpu_mask = _morph_apply_gpu(morph, gpu_mask, stream)

        # 1ch → 3ch (robust)
        gpu_mask3 = _to3_gpu(gpu_mask, stream, w, h)

        # highlight
        gain = 0.70
        try:
            gpu_out = cv2.cuda.addWeighted(gpu_bgr, 1.0, gpu_mask3, gain, 0.0, None, -1, stream)
        except Exception:
            gpu_out = cv2.cuda.addWeighted(gpu_bgr, 1.0, gpu_mask3, gain, 0.0)

        stream.waitForCompletion()
        out = gpu_out.download()
        try:
            pipe.stdin.write(out.tobytes())
        except BrokenPipeError:
            raise RuntimeError("FFmpeg-Pipe geschlossen (rtsp Ziel erreichbar?)")

        # fps log
        t_now = time.time(); dt = max(1e-6, t_now - t_prev); t_prev = t_now
        cur = 1.0/dt; ema = cur if ema is None else (0.85*ema + 0.15*cur)
        if log.upper() in ("DEBUG","INFO"):
            print(f"[highlight] fps~{cur:0.2f} (ema={ema:0.2f})", flush=True)

        if fps_target and fps_target>0:
            sl = max(0.0, (1.0/fps_target)-dt)
            if sl>0: time.sleep(sl)
